Below is a concrete, reviewer-facing proposal of what to formalize in Agda,
structured as a proof roadmap rather than a grab-bag of lemmas. The goal is
to maximize semantic leverage per proof hour and to respect Prism's
philosophy: prove what matters, not everything.

This is organized into five tiers:

1) Foundational objects to encode
2) Core theorems worth proving
3) Boundary theorems (negative capability)
4) Min(Prism) exhaustiveness theorems
5) What explicitly should not be proved in Agda

For each item, it notes why it's worth proving, what it buys you, and what the
Agda shape likely looks like.

---

# in-26.md — Agda Proof Roadmap for Prism (Semantic Kernel)

> Status: Draft (reviewer-facing proof plan)
>
> Audience: Prism core developers, semantics reviewers, verification authors
>
> Milestone: m3+ (semantic kernel formalization; no operational changes)
>
> Prereqs: in-18.md through in-25.md, in/glossary.md

---

## 0. Meta-Guideline (Important)

Do not formalize "Prism the implementation." Formalize Prism the semantic
kernel:

* Sigma (finite signature, arity <= 2)
* canonical keys and univalence
* q as a quotient / normalization
* BSPˢ as an equivalence relation
* canonical novelty as a monotone
* finite semantic closure (Min(Prism))

Everything else is engineering.

---

## 1. Foundational Objects to Encode

These are prerequisites. Keep them minimal.

### 1.1 Finite Signature Sigma

Agda object:

```agda
data Op : Set where
  add mul suc zero coordPair coordZero coordOne : Op

arity : Op -> Nat
arity add = 2
arity mul = 2
arity suc = 1
arity zero = 0
...
```

Why:
* All boundedness results depend on Sigma being finite and arity-bounded.
* This is the root of canonical novelty saturation.

---

### 1.2 Canonical Terms (Semantic Keys)

Define canonical semantic objects, not syntax trees.

Agda object:

```agda
data Key : Set where
  node : (op : Op) -> Vec Key (arity op) -> Key
```

Optionally quotient by commutativity for add/mul at definition time.

Why:
* This is the Ledger, not the Arena.
* Everything meaningful happens here.

---

### 1.3 Univalence (Canonical Identity)

You want propositional equality = semantic equality.

Agda statement:

```agda
univalence : forall {k1 k2 : Key} -> k1 ≡ k2 <-> semanticEq k1 k2
```

(semanticEq is structural equality after canonicalization.)

Why:
* This is Prism's strongest invariant.
* It is the foundation of everything else.

---

## 2. Core Theorems to Prove (High Value)

These are the non-negotiable proofs. If you prove only these, Prism already
stands on solid ground.

### 2.1 BSPˢ Is a Gauge Symmetry

Formalize BSPˢ as an equivalence relation on Arena states and prove it is
erased by q.

Agda shape:

```agda
_≈ˢ_ : Arena -> Arena -> Set  -- BSPˢ equivalence

q-invariant :
  forall {A A'} ->
  A ≈ˢ A' ->
  q A ≡ q A'
```

Why:
* This is the semantic firewall that enables refactoring, parallelism, locality.
* Reviewers will look for this exact statement.

---

### 2.2 Canonical Novelty Is Monotone

Define canonical novelty abstractly (as a growing set of Keys).

Agda shape:

```agda
Novelty : Execution -> Set Key

monotone-novelty :
  forall {E1 E2} ->
  E1 <= E2 ->
  Novelty E1 ⊆ Novelty E2
```

Why:
* This replaces ordinal descent as the control mechanism.
* It is the key semantic monotone in the system.

---

### 2.3 Bounded Semantic Novelty (Finite Closure)

This is the most important theorem.

Statement:
The set of semantic keys generated by Sigma is finite up to canonical equality
(for fixed bounds).

Agda shape:

```agda
finite-closure :
  forall (Sigma : FiniteSignature) ->
  Finite (Closure Sigma)
```

Or constructively:

```agda
closure-enumerable :
  List Key
```

with proof that it is closed under Sigma-construction.

Why:
* This is what makes TREE-class representation finite.
* This underwrites Min(Prism).

---

### 2.4 Representation Fixed Point Theorem

Formalize eventual stabilization of representation.

Agda shape:

```agda
exists-fixed-point :
  forall (E : Execution) ->
  exists (fun n ->
    forall m -> m >= n ->
      Novelty (step m E) ≡ Novelty (step n E))
```

Why:
* This is the semantic content of "hyperoperators stabilize".
* It does not imply termination.

---

### 2.5 Orthogonality to Termination

Prove that no descending measure exists.

Agda statement:

```agda
no-ordinal-measure :
  not (exists (fun mu ->
       forall step -> mu (next step) < mu step))
```

You can weaken "ordinal" to "well-founded order."

Why:
* This prevents reviewers from misreading novelty as ordinal descent.
* It protects the boundary in in-25.

---

## 3. Boundary / Negative Capability Theorems (Very Important)

These are rarely proved in formalizations, which is why doing so is impressive.

### 3.1 Canonical Novelty != Termination

Agda:

```agda
novelty-not-termination :
  exists (fun E ->
    (exists (fun n -> forall m -> m >= n ->
      Novelty (step m E) ≡ Novelty (step n E)))
    × (not (terminates E)))
```

Why:
* This makes TREE-class claims precise.
* This disarms a whole class of objections.

---

### 3.2 No Quantitative Semantics Survive q

Agda:

```agda
q-erases-multiplicity :
  forall {A} -> q (A ++ A) ≡ q A
```

Generalized: q factors through a set-like quotient, not a multiset.

Why:
* This justifies why cost models, probabilities, weights are out of scope.
* It anchors the entropy taxonomy in proof, not prose.

---

### 3.3 No State Mutation in the Ledger

Agda:

```agda
ledger-immutable :
  forall {L} (step : ExecutionStep) ->
  Ledger step ≡ Ledger (step ∘ step)
```

Meaning: Ledger objects never change identity.

Why:
* This enforces univalence at the semantic level.
* It separates Prism from CRDTs formally.

---

## 4. Min(Prism) Proofs (High Prestige, Moderate Effort)

These are the proofs reviewers love.

### 4.1 Finite Semantic State Space

Agda:

```agda
finite-semantic-states :
  Finite (SemanticState K)
```

Where SemanticState K is the Ledger modulo equivalence, bounded by K.

Why:
* This enables exhaustive verification.
* This is rare in real systems.

---

### 4.2 Projection Commutation

Formalize the D.5.O obligation.

Agda:

```agda
projection-commutes :
  forall {S} ->
  canon (pi_K (step S)) ≡ canon (step_K (pi_K S))
```

Why:
* This is the refinement argument.
* This is what makes Min(Prism) sound.

---

## 5. What You Should Not Prove in Agda

This restraint matters.

* Do NOT prove termination.
  - It is false in general.
  - It weakens your position if attempted.
* Do NOT formalize Arena execution in full.
  - Too big, too operational.
  - Semantics live in the Ledger.
* Do NOT encode ordinal analyses.
  - Contradicts your design.
  - Sends the wrong signal.
* Do NOT prove performance properties.
  - Irrelevant to semantic claims.
  - Actively harmful in review.

---

## 6. Suggested Agda Module Structure

```text
Prism/
  Signature.agda          -- Sigma, arity, finiteness
  Key.agda                -- canonical semantic objects
  Univalence.agda         -- identity = equality
  Gauge.agda              -- BSPˢ equivalence, q-invariance
  Novelty.agda            -- monotone, saturation
  FixedPoint.agda         -- representation stabilization
  MinPrism.agda           -- finite state space
  Boundaries.agda         -- non-termination, no ordinals
```

Each file should be under 300 lines if done right.

---

## 7. Final Recommendation (Strategic)

If you prove only five things in Agda, prove these:

1) Univalence
2) BSPˢ gauge invariance
3) Monotonicity of canonical novelty
4) Finiteness of semantic closure
5) Existence of representation fixed points without termination

That set alone is enough to make Prism's claims extremely hard to dismiss.
