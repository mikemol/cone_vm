# 2:1 Alternating BSP Layout for Hierarchical Graph Locality

NOTE: REFINED by in-14.md; hierarchical arenas are a performance-only layer (M5 optional).

## 1. The Geometry of Memory: Addressing the "Shatter"

The "Shatter Effect" describes the entropy generated by parallel graph reduction: when a dense wavefront of active nodes () reduces, it spawns children () that are logically related but, in a naive linear heap, are allocated to random, scattered addresses. This scattering destroys spatial locality for the *next* reduction cycle, causing cache thrashing and memory divergence.

The proposed solution imposes a strict **Geometric Constraint** on the memory address space. By viewing the linear arena not as a 1D array but as a **2:1 Alternating Binary Space Partitioning (BSP) Tree**, we enforce a recursive locality invariant: *logical proximity implies physical proximity*.

### 1.1 The 2:1 Alternating BSP Tree Structure

Unlike a standard Quadtree (which splits X and Y simultaneously to create 4 square children), an Alternating BSP tree splits only *one* axis at a time. The "2:1" constraint refers to the aspect ratio of the nodes at each level of the hierarchy.

* **Level  (Square):** A block of memory representing a square region of the graph topology.
* **Level  (Rectangle):** The parent is split along the X-axis. The children are  rectangles.
* **Level  (Square):** The children are split along the Y-axis. The resulting grandchildren are squares () again.

**Memory Mapping (Interleaved Bits):**
This structure corresponds to a specific bit-interleaving pattern (Morton Code) where bits are taken strictly one-by-one from X and Y alternatingly.
If an address  is composed of bits , they map to coordinates  as:



(assuming X is the first split).

This layout ensures that any contiguous range of memory (an aligned block) corresponds to a compact rectangular or square region in the logical graph space.

---

## 2. Hierarchical Arenas: Constraining the Blast Radius

To mitigate the shatter effect, we replace the single global arena with a **Hierarchy of Arenas** defined by the BSP tree.

### 2.1 The Hierarchy Definition

We define a hierarchy depth  (e.g.,  levels).

* **L0 Arenas (Global):** The entire device memory (HBM).
* **L1 Arenas (Cluster):** Sub-regions mapped to GPU Streaming Multiprocessors (SMs) or TPU Cores.
* **L2 Arenas (Local):** Small, cache-sized blocks (e.g., 64KB) mapped to Thread Blocks or Warps.

### 2.2 Locality-Preserving Allocation

When a node in an L2 Arena reduces and produces children:

1. **Attempt L2 Allocation:** It tries to allocate the children *within the same L2 arena*. Since the L2 arena corresponds to a leaf in the BSP tree, these addresses are physically adjacent.
2. **Overflow to L1:** If the L2 arena is full, it overflows to the parent L1 arena (the sibling node in the BSP tree).
3. **Shatter Containment:** The "shatter" (scattered writes) is contained within the subtree. A node at  will write its output to the neighborhood of . The 2:1 layout ensures that "neighborhood" translates to "nearby memory rows".

This converts global random access (uncoalesced) into **Block-Strided Access**, which GPUs can handle efficiently via cache line coalescing.

---

## 3. The 2-Bit Rank Scalar: Radical Simplification

By constraining the `Rank` scalar to exactly 2 bits, we reduce the scheduling state space to 4 distinct phases. This allows us to replace the expensive `argsort` () with a highly optimized **4-Bin Counting Sort** or **Stream Partition** ().

### 3.1 The 2-Bit Ontology

The 2 bits partition the nodes into 4 classes, sorted by execution urgency:

| Rank (Binary) | Class | Description | Memory Location (Pack) |
| --- | --- | --- | --- |
| **00** | **HOT** | Active Redexes ready to fire immediately. | Top of Arena (Contiguous) |
| **01** | **WARM** | Direct descendants/neighbors of HOT nodes. Likely to become HOT next. | Middle-Top |
| **10** | **COLD** | Deeply nested or waiting nodes. | Middle-Bottom |
| **11** | **FREE** | Garbage/Empty slots. | Bottom (available for alloc) |

### 3.2 The Physics of the Cycle

1. **Execution (HOT):** The GPU processes only the `00` range.
2. **Shatter (Write):** New nodes are written. Instead of searching for free space, they are written to the `11` (FREE) region using atomic cursors *within the local BSP block*.
3. **Promotion (Rank Update):**
* `HOT` nodes that finished become `FREE` (11).
* `WARM` nodes connected to finished redexes become `HOT` (00).
* New nodes are born as `WARM` (01) or `COLD` (10).


4. **Pack (Sort):** We run a 4-bin sort. Because the keys are only 2 bits, this is done via 3 bit-mask passes (or a single specialized kernel), which is order-of-magnitude faster than full sorting.

---

## 4. JAX Implementation Strategy

We can simulate the 2:1 BSP layout in JAX using `jax.lax.scatter` and bit-manipulation for address swizzling.

### 4.1 2:1 BSP Address Swizzling

```python
import jax.numpy as jnp

def swizzle_2to1(x, y):
    """
    Interleaves bits of x and y to form a 2:1 BSP address.
    Assumes 32-bit coordinates.
    Pattern: x0 y0 x1 y1 x2 y2...
    """
    # In a real kernel, use dedicated bit-interleaving intrinsics (PDEP/PEXT on CPU).
    # In JAX/XLA, we simulate via shifts. 
    # (Note: This is expensive in pure Python/JAX, optimally done in a Pallas kernel)
    
    z = jnp.zeros_like(x, dtype=jnp.uint64)
    for i in range(16):
        x_bit = (x >> i) & 1
        y_bit = (y >> i) & 1
        z |= (x_bit << (2 * i)) | (y_bit << (2 * i + 1))
    return z

def deswizzle_2to1(z):
    """Separates Z-curve address back to X, Y coordinates."""
    x = jnp.zeros_like(z, dtype=jnp.uint32)
    y = jnp.zeros_like(z, dtype=jnp.uint32)
    for i in range(16):
        x |= ((z >> (2 * i)) & 1) << i
        y |= ((z >> (2 * i + 1)) & 1) << i
    return x, y

```

### 4.2 The Hierarchical Loop

The execution loop effectively "breathes": expanding into the hierarchy during interaction (shatter) and contracting back during the pack phase.

```python
def step(arena):
    # 1. Rank: Classify nodes (00, 01, 10, 11)
    ranks = classify_nodes(arena)
    
    # 2. Pack: 4-Bin Sort (Moves 00 to top, 11 to bottom)
    # Using argsort for simplicity, but Bucket Sort is implied.
    perm = jnp.argsort(ranks)
    arena = apply_permutation(arena, perm)
    
    # 3. Swizzle: Update pointers using Inverse Permutation
    inv_perm = invert_permutation(perm)
    arena = update_pointers(arena, inv_perm)
    
    # 4. Execute: Run interaction on Rank 00 (HOT) partition
    # New nodes are emitted with locality hints (preferred BSP block)
    arena = interaction_kernel(arena, limit=count_hot)
    
    return arena

```

### 4.3 Why this fixes the Shatter Effect

In a linear arena, if node  at index 0 interacts with node  at index 1000, their children might end up at indices 50 and 5000.
In the **2:1 BSP Arena**:

1.  and  are likely in the same or adjacent BSP blocks (spatial locality).
2. When they produce children, the allocator prefers the `FREE` slots *within that same BSP block*.
3. The 2-bit sort preserves the relative order of blocks (stable sort).
4. Therefore, the children remain clustered in memory. When they become `HOT` in the next cycle, they are fetched as a contiguous cache line.
