NOTE: Incorporated into IMPLEMENTATION_PLAN.md; this document remains the rationale and reconciliation pass.

This is a strong plan. The main thing to tighten is **the separation of semantic spine vs. performance spine**, and to make **univalence** a first-class invariant (with explicit “what constitutes a key” and “what constitutes equality” written down once and reused everywhere).

Below is a concrete reconciliation / edit pass that makes the plan internally consistent with your stated goals.

---

## 1) One architectural correction: you currently have *two* “canonical paths”

Your Goals say:

> “Establish the Ledger + candidate pipeline as the canonical execution path.”

…but the plan also spends M1–M5 building an **Arena rank/sort/swizzle/interact** semantic loop, and only later introduces the CNF-2 candidate pipeline as a separate thing.

That creates ambiguity: is correctness proven against **Arena semantics** or **Ledger semantics**?

### Fix

Make it explicit:

* **Semantic engine (canonical):** `Ledger + CNF-2 candidate pipeline + intern_nodes`
* **Scheduling engine (performance-only):** `Arena rank/sort/swizzle/morton` (must be denotation-invariant wrt the semantic engine)

In practice:

* M1–M3 should be **Ledger-only** (no Arena required).
* Arena work starts at M4 as an optimization layer that must pass denotation-invariance tests.

This matches your “Stage arena scheduling and 2:1 BSP locality as performance-only concerns.”

---

## 2) Univalence needs a single, explicit contract

Right now you say:

* “full-key equality; hash is hint only”
* “no truncation aliasing”

But you never pin down the exact key definition across all opcodes and derived representations (especially once CD coordinates enter).

### Add a short “Univalence Contract” section (single source of truth)

**Key(K):** a byte sequence derived from a node after canonicalization:

* `K = encode(op) || encode(rep(a1)) || encode(rep(a2)) || encode(extra(op))`
* For commutative ops, `rep(a1), rep(a2)` are sorted (by representative id or by key bytes).
* `rep(id)` is either `id` (M1–M2) or `find(id)` if/when rewrite-union is introduced.

**Equality:** two nodes are equal iff their full `K` bytes are equal.

**Indexing:** hash/bucket is only acceleration; equality is decided by full `K`.

**Anti-aliasing rule:** encoding never truncates child ids. If you use fixed-width encoding, it must be wide enough for the maximum id in the model.

This turns “univalence” into something you can test everywhere, including coordinates.

---

## 3) Milestone rewrite: make M1–M3 purely Ledger/CNF-2

### Revised milestones (minimal change to your intent)

**M1: Canonical interning + intrinsic rewrite (Ledger only)**

* `cycle_intrinsic` + `intern_nodes` is the reference evaluator.
* Baseline PrismVM is oracle.
* Tests: univalence, key-width, baseline equivalence on small programs, plus one property test.

**M2: CNF-2 candidate pipeline (Ledger only)**

* Replace intrinsic rewrite emission with `emit_candidates -> compact -> intern -> update frontier`.
* Slot 1 disabled is fine.
* Tests: fixed arity, compaction, baseline equivalence.

**M3: Strata discipline + coordinates (Ledger only)**

* Stratum boundaries + validator
* `OP_COORD_*` nodes + coordinate normalization “canonicalize-before-pack”
* Tests: no within-tier refs, coordinate pointer equality, parity cancellation idempotence.

**M4+: Arena scheduling + morton/2:1 locality (performance only)**

* Arena becomes an *implementation strategy* to accelerate candidate selection / locality.
* Must pass denotation-invariance across modes.

This keeps your plan intact, just reorders to eliminate semantic ambiguity.

---

## 4) One concrete semantic gap: ADD rules must be symmetric everywhere

Your plan states “CNF-2 symmetric rewrite semantics,” but the current `op_interact` (and some of the earlier logic) historically tends to be asymmetric (zero/suc only on `a1` in a few places).

### Add an explicit rewrite spec table (even if partial)

For MVP:

* `add(zero, y) -> y`
* `add(x, zero) -> x`
* `add(suc(x), y) -> suc(add(x, y))`
* `add(x, suc(y)) -> suc(add(x, y))`  (commutativity can reduce this to one case if you canonicalize args)

…and say: **the canonicalization step enforces commutative ordering so only one “suc-side” needs to be implemented**.

That makes “symmetry” an explicit outcome, not a wish.

---

## 5) Tests: add two “meta-tests” that will save you days

You already have good unit tests. Two additions:

### A) Cross-engine equivalence harness

A single parametrized test that runs the same small program suite through:

* Baseline PrismVM
* Ledger intrinsic
* Ledger CNF-2 pipeline
* (later) Arena scheduled

…and asserts decoded normal forms match (or asserts canonical ids match *within one engine*).

This catches drift immediately.

### B) Small randomized generator (property test)

Generate tiny expressions with bounded depth, run:

* baseline eval
* bsp eval (for N cycles or until fixed point)

Assert same normal form.

Even without Hypothesis, a hand-rolled generator + fixed seeds works.

---

## 6) CQRS/event sourcing: you can keep it “in-memory” and still get the benefits

You say persistent event log is non-goal (fine). But you still want the *shape*:

* Commands: `Intern(key)` / `Rewrite(old->new)`
* Read model: `index + node tables`

### Suggestion

Add a tiny “event counter” and optional debug recording in tests:

* record the batch of interned keys per cycle
* replay into a fresh ledger and assert the same `ids_sorted`/`count` results

That gives you **deterministic rebuildability** without committing to storage formats yet.

---

## 7) Coordinate semantics: pin down the “canonicalize-before-pack” rule

You mention it, but make it crisp:

* `OP_COORD_ZERO` and `OP_COORD_ONE` are leaf nodes with `(a1,a2) = (0,0)` and are canonical.
* `OP_COORD_PAIR(a,b)` must be canonicalized such that:

  * children are already canonical coordinate objects
  * optional normalization rules (if any) are applied before interning
* XOR/parity cancellation must be implemented as **rewrites that produce canonical coordinate objects** (not as external metadata).

Then: coordinate equality is pointer equality *because interning enforces structural identity*.

---

## 8) “Slot 1 disabled” is okay, but write down what slot 1 will mean

Right now slot 1 is “future continuation/strata.” Good. Just add one sentence:

* Slot 0 = “primary rewrite result”
* Slot 1 = “continuation / wrapper / reconstitution step” (e.g., the outer `suc(...)` wrap or `add(...)` re-embedding)

This prevents later confusion when you turn it on.

---

## What I would change in your text (minimal patch)

If you want the fastest path, change only these three parts:

1. In **Architecture Decision**, add:
   “Arena scheduling is performance-only and must be denotation-invariant with respect to the Ledger CNF-2 engine.”

2. In **Milestones**, reorder so M1–M3 are Ledger-only; move Arena sorting/morton to M4+.

3. Add a short **Univalence Contract** section defining key bytes + equality + no truncation.
