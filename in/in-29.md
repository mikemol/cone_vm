Perfect. Given everything we’ve now locked in, the right move is a **ground-up rewrite** of `in-29.md` so that:

* it no longer reads like an incremental clarification,
* it stands on its own as a **semantic keystone**,
* it encodes *hierarchy, BSP, Morton coding, spillway, IC collapse, and facade control* as one coherent design,
* and it is **unambiguous enough for Codex to implement mechanically**.

Below is a **full replacement** for `in/in-29.md`. This is not a patch or addendum; it assumes the reader has access to earlier `in-*` files (especially 8–27) but does not rely on them for correctness.

---

```markdown
# in-29.md — Hierarchical BSP Arenas, Spillway Semantics, and Facade-Controlled Backoff

## Status
Normative

## Scope
This document defines the **hierarchical execution semantics** of ConeVM, unifying:

- Binary Space Partitioning (BSP),
- Interaction Combinators (IC),
- Contract / Sort / Reduce (CSR),
- Morton-coded arena layouts,
- Spillway-based expansion detection,
- and facade-controlled servo actuation.

This document supersedes all prior informal interpretations of “spill”, “damage”, and “backoff”.
All future implementation and optimization work MUST preserve the invariants defined here.

---

## 1. Background and Lineage

This design is enabled by, and should be read in the context of:

- `audit_in_versions.md` — semantic epoch mapping
- `in-8.md` — interaction combinators and locality
- `in-17.md` — lawful representations and binding without names
- CNF-2 candidate normalization
- Existing damage telemetry infrastructure

What was previously *observational* (damage metrics) is here made *semantic*.

---

## 2. Dual Meaning of BSP (Intentional)

In ConeVM, **BSP has two meanings, intentionally unified**:

1. **Bulk Synchronous Parallelism**  
   Execution proceeds in uniform, warp-safe passes (“microstrata”).

2. **Binary Space Partitioning**  
   The node index space is hierarchically partitioned into nested binary arenas.

These are not metaphors.  
They are the *same structure*, viewed operationally and spatially.

---

## 3. Hierarchical Arena Model

### 3.1 Binary Arena Tree

The node index space is partitioned as a perfect binary tree:

- Level 0: arenas of size 1
- Level 1: arenas of size 2
- Level 2: arenas of size 4
- …
- Level k: arenas of size 2^k

Each arena is the union of exactly two child arenas.

Arenas are **logical envelopes**, not heap objects.
They are views over contiguous index ranges.

---

### 3.2 Morton Coding as Arena Arithmetic

Nodes are indexed using **Morton (Z-order) codes**.

Properties:

- High-order bits identify the arena (partition) at a given level.
- Shifting right corresponds to promotion to the parent arena.
- Contiguous indices correspond to spatial and interaction locality.

Morton coding is therefore the arithmetic realization of the BSP tree.

---

## 4. Active Region and Spillway

Each arena at level k is structurally divided into:

- **Active region**: size 2^k  
  The current work frontier.

- **Spillway region**: size 2^k  
  Reserved exclusively for expansive emission.

Total arena capacity: 2^(k+1).

This 2:1 structure is mandatory and invariant.

---

## 5. Spillway Is Not Slack

The spillway is **not** a performance buffer.

It is a **constructive bound on worst-case state expansion** for a single microstratum pass.

### 5.1 CNF-2 Justification

In CNF-2 candidate generation:

- Each active item produces at most 2 outputs.
- Baseline replacement consumes 1 slot.
- Maximum expansion is +1 per item.

Thus, for N active items:

```

E_max = N

```

A spillway of size N is both necessary and sufficient.

### 5.2 Wrapper (Depth) Emission

Wrapper emission (e.g. `OP_SUC`) proceeds across microstrata:

- Each microstep is 1→1.
- Expansion manifests across depth, not as a burst.

Spillway usage therefore remains a valid witness of expansion pressure,
even when depth-driven.

---

## 6. Normative Spillway Rule

**Invariant (non-negotiable):**

```

If spillway_used > 0 during a microstratum pass,
then the current arena level is no longer safe.

```

There are:

- no thresholds,
- no hysteresis,
- no tuning parameters.

**Any** spillway usage is sufficient.

---

## 7. Backoff Semantics

“Backoff” has a precise meaning:

> **Escalation to a strictly larger arena in the BSP tree.**

This may involve one or more of:

- promotion to the parent arena (bit-shift of Morton codes),
- widening of the locality envelope,
- termination of the current microstratum and macrostratum reconciliation.

Backoff is:

- uniform (one decision per pass),
- deterministic,
- executed only at stratum boundaries.

---

## 8. Relationship to Masking and Noops

Masking and identity/noop operators are reserved for:

- semantic ineligibility:
  - already resolved,
  - not ready,
  - forbidden by policy.

Spillway usage is **not** semantic failure.

Therefore:

- Spillway usage MUST NOT cause noops.
- Spillway usage MUST cause backoff.

These concerns are orthogonal.

---

## 9. Telemetry as Semantic Witness

Telemetry is elevated from observation to **proof**.

At minimum, each microstratum pass MUST produce:

- `spillway_used` (boolean or count).

Optional corroborating witnesses include:

- damage rate (cross-arena edges),
- CNF-2 churn counters.

Servo decisions MUST be derivable solely from these witnesses.

---

## 10. Facade as Hierarchical Controller

The **facade** is the unique locus of hierarchical control.

Responsibilities:

- track current arena level,
- invoke a single microstratum pass at that level,
- inspect structural witnesses (spillway usage),
- decide escalation or continuation,
- select Morton resolution and swizzle policy,
- define macrostratum boundaries.

Kernels:
- operate strictly within a single arena,
- are branchless and warp-uniform,
- emit witnesses but never decide escalation.

The REPL is observational only.

---

## 10.x Ledger as Terminal Arena (Settlement)

The ledger is the **terminal** node of the hierarchical BSP arena model.

### Normative meaning (“settled”)

The ledger is where hierarchical exploration stops:

- There is **no spillway**.
- Expansion is **forbidden**.
- Identities are **canonical** (univalent) and globally visible.
- The pre-step ledger segment is **read-only** during a cycle; interning is **append-only** relative to that base.

This is the precise sense in which the ledger is *settled*.

### Implementation note (not an arena buffer)

The ledger is not implemented as “a bigger arena buffer.”
It is an append-only canonical store plus derived indexes (CQRS / event-sourced read model):
- `key_bytes -> id`
- `id -> (op, a1, a2)` (or equivalent packed form)

This difference is intentional: settlement requires globally canonical lookup, not locality-bounded rewrite.

### Facade role

Promotion/backoff traverses the BSP hierarchy over arenas.
At the root (no parent arena exists), the only lawful resolution of remaining work is settlement:
the facade must commit into the ledger (canonicalization) rather than attempting further arena-local expansion.

### Test obligations (existing)

- (m1) `tests/test_m1_gate.py::test_ledger_full_key_equality`
- (m1) `tests/test_candidate_cycle.py::test_cycle_candidates_does_not_mutate_preexisting_rows`
- (m2) `tests/test_ledger_intern.py::test_intern_nodes_never_mutates_pre_step_segment`

---

## 11. IC and BSP Reconciliation

Interaction Combinators (IC) and BSP normalization are not competing models.

They are:

- the same rewrite rules,
- applied at different depths of the BSP tree.

IC naturally occupies lower levels (tight locality).
BSP normalization naturally occurs at higher levels.

The facade mediates between them via arena level selection.

---

## 12. Consequences

This design:

- forbids global scans at low levels,
- guarantees bounded expansion per pass,
- enforces locality without heuristics,
- prevents warp divergence,
- aligns execution, memory hierarchy, and semantics,
- explains the prevalence of CNF-2 and 2:1 structures,
- makes “damage” and “spill” mathematically precise.

---

## 13. Summary

ConeVM execution is traversal of a binary space partition over node index space.

- Morton coding defines the partition.
- CSR defines work resolution within a partition.
- Spillway usage detects boundary crossing.
- Backoff is escalation in the BSP tree.
- The facade is the traversal controller.

This structure is fundamental and final.
```

---

### What you now have

* A **clean semantic keystone document**
* No dangling heuristics
* No ambiguity between IC/BSP/CSR
* A direct mapping from theory → code → memory hierarchy
* Something Codex can follow *without interpretation*

If you want, next we can:

* add an `in-29` glossary delta,
* write an `implementation obligations` checklist for Codex,
* or draft `in-30.md` as the *facade execution contract* that turns this into API-level requirements.

Just point to the next lock-in.
