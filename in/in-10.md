NOTE: CONSOLIDATED by in-13.md; CD coordinates are made self-hosted in in-11.md.

Perfect. Here is a **clean, engineering-grade technical diff** you can use as a milestone definition. It is written so that:

* it is **formally precise** (no philosophy required to parse it),
* it clearly distinguishes **what stays invariant** vs **what changes**,
* it is **auditable** (you can point to code loci),
* and it accurately reflects the Cayley–Dickson (CD), CNF-2, GF(2) intent you’ve converged on.

I’ll structure this as a *delta spec* rather than a redesign.

---

# PrismVM Milestone Δ:

**From Tree-Local Rewriting to CD-Addressed Aggregation**

---

## 0. Milestone Statement (one paragraph you can reuse verbatim)

> This milestone upgrades PrismVM from a tree-local rewrite engine with syntactic deduplication to a CD-addressed aggregation engine in which commutative–cancellative semantics (GF(2)) are finitely observable via explicit Cayley–Dickson coordinate lifting. The core arena/ledger, interning, and BSP scheduling mechanisms remain unchanged; the delta consists of (i) introducing explicit CD coordinates as first-class IR data, and (ii) redefining aggregation operators to normalize over CD address space rather than tree topology.

---

## 1. What remains invariant (important for reviewer trust)

These are **explicit non-changes**.

### 1.1 Execution substrate (unchanged)

* Arena / Ledger storage model
* Pointer-addressed DAG of rows
* Interning as canonicalization mechanism
* BSP / frontier cycling
* Rank, sort, swizzle, Morton logic
* Stratum invariant: “no within-tier references”

> **Invariant:** Evaluation remains “rewrite by allocation + dedup + frontier propagation”.

---

### 1.2 IR arity (unchanged *physically*)

* Rows remain `(opcode, arg1, arg2)`
* CNF-2 is a **semantic view**, not a storage rewrite

> **Invariant:** No forced migration to explicit edge triples or higher-arity rows.

---

## 2. What changes (the actual diff)

### 2.1 New first-class concept: **CD Coordinate**

#### Definition

A **CD coordinate** is a finite bitstring (or digit vector) representing the relative address of a substructure in the Cayley–Dickson lift.

* Operationally: base-2 / base-256 digits (Option B-compatible)
* Algebraically: elements of an XOR-group under bitwise XOR
* Semantically: “relative position” in lifted binary space

#### Engineering commitment

Each **aggregation-participating node** carries or computes a CD coordinate.

This can be implemented as:

* an explicit `coord` field (parallel array), **or**
* an implicit derived value cached during normalization

> **New invariant:** Aggregation semantics are defined over CD coordinates, not tree adjacency.

---

### 2.2 Redefinition of aggregation operators (core semantic shift)

This is the most important diff.

#### Before

* `OP_ADD`, `OP_MUL` operate over **tree structure**
* Cancellation/identity requires adjacency or explicit rewrite rules
* Deduplication collapses *identical subtrees only*

#### After

* Aggregation ops are interpreted as **CD-lifted aggregators**
* Normal form is defined in **CD address space**
* Cancellation is parity-based (GF(2)) and **coordinate-local**

Concretely:

| Aspect       | Before                                      | After                                   |
| ------------ | ------------------------------------------- | --------------------------------------- |
| Domain       | Binary tree fragments                       | Finite CD-addressed aggregates          |
| Equality     | Pointer equality after interning            | Parity equality over coordinates        |
| Cancellation | Local rewrite (`x ⊕ x → 0`) only if exposed | Automatic via parity at same coordinate |
| Locality     | Tree adjacency                              | CD-coordinate coincidence               |

---

### 2.3 Canonicalization hook at interning boundary (new)

A new **payload-level canonicalization hook** is introduced:

```text
canonicalize(op, arg1, arg2) -> (op', arg1', arg2') OR aggregate
```

Responsibilities:

1. **Commutativity:** canonical ordering if applicable
2. **CD lifting:** compute derived CD coordinates
3. **Aggregation:** collapse operands into parity-normalized form
4. **Idempotence:** ensure repeated canonicalization is a projection

> **Key point:** This happens *before* `intern_nodes` key construction.

This ensures:

* rapid deduplication,
* no representation blowup,
* frontier volatility becomes effective.

---

### 2.4 New aggregate normal form (conceptual, not storage-breaking)

Aggregation results are represented as **canonical parity aggregates**, not raw binary trees.

Acceptable representations:

* parity-sets of CD coordinates
* parity-tries (CNF-2-compatible)
* equivalent canonical DAGs

> **Invariant:** Aggregate normal form is **unique**, **idempotent**, and **coordinate-based**.

---

## 3. Locality and scope: formal resolution

### 3.1 Previous locality (insufficient)

* “Binary fragment + ancestors”
* Topological neighborhood in tree

### 3.2 New locality (CD-sound)

* “Maximal connected component under CD aggregation”
* Scope is defined by **coordinate reachability**, not depth

> **Formal claim:**
> Parity is finitely observable in the CD-lifted address space.

This is the sheaf-correct resolution:

* local universes are **CD-complete**
* descent holds
* global normalization emerges by idempotent projection

---

## 4. Cut elimination: status after the diff

### Before

* Cut elimination = semantic theorem
* Engine relies on chance adjacency

### After

* Cut = coordinate collision
* Elimination = local parity toggle
* Normalization = idempotent aggregation

> **Engineering restatement:**
> Cut elimination is implemented, not proven.

---

## 5. BSP / frontier semantics after the change

| Aspect              | Effect                                          |
| ------------------- | ----------------------------------------------- |
| Frontier volatility | Now guaranteed to expose cancellations          |
| Strata              | Correspond to CD-lift layers                    |
| Dedup speed         | Increases (canonical aggregates collapse early) |
| Scheduling          | Unchanged                                       |

---

## 6. Minimal code-touch summary (what actually changes in code)

You can literally hand this to yourself or a collaborator.

### Required additions

* CD coordinate representation (digit vector or bitset)
* Canonicalization hook invoked by `intern_nodes`
* Aggregate normalization routine (GF(2) parity)

### Modified components

* `intern_nodes` → calls canonicalize before key pack
* Candidate emission → operates on aggregates, not raw trees
* (Optional) Ledger key lanes extended to include coordinate info

### Explicitly *not* required

* Rewriting Arena/Ledger
* Removing Peano example
* Changing BSP infrastructure
* Introducing uint64

---

## 7. Milestone acceptance criteria (very important)

This milestone is **complete** when:

1. Two aggregation expressions that differ only by tree shape but represent the same CD-aggregate intern to the same pointer.
2. Duplicate operands at the same CD coordinate cancel **without requiring adjacency**.
3. Canonicalization is idempotent (`canon(canon(x)) == canon(x)`).
4. Frontier cycling converges in fewer steps for aggregation-heavy workloads.
5. Existing Peano demo continues to work as a payload (even if not using CD).

---

## 8. One-sentence executive summary

> This milestone makes Cayley–Dickson relative addressing *operational* by lifting aggregation semantics into explicit CD coordinate space, turning parity and cut elimination from global semantic properties into local, idempotent, engine-enforced invariants—without changing PrismVM’s core execution model.

If you want, next I can:

* draft a **code-level checklist** mapping this diff onto specific functions in your file, or
* help you write the **Milestone PR description / design doc header** that would survive a serious technical review.
