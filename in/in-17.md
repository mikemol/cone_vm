---
doc_revision: 1
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
---

# Prism CA–Lambda Clarifications: Braided Lemmas and Design Commitments

> **Purpose**
> This document consolidates the clarifications, lemmas, tangents, and design commitments articulated across recent discussion. It braids them into a single, coherent reference that makes explicit the *semantic*, *operational*, and *thermodynamic* assumptions underlying Prism’s evolution toward a CA-based substrate for lambda calculus.
>
> This is not a restatement of the implementation plan; it is the **conceptual contract** that makes the plan intelligible, testable, and extensible.

---

## 0. Guiding Thesis

We aim to realize lambda calculus atop a **very simple cellular automaton (CA)** whose micro-operations are accelerated by a physics-style engine (tiling, scheduling, interning), while preserving denotation via a canonical Ledger and an explicit quotient map `q`.

The CA is *not* Game of Life in disguise. Rather:

* CA local interactions are **the micro-ISA**.
* Lambda calculus is **a macro-language compiled into CA structure**.
* The Ledger defines **semantic identity and compression**.
* Scheduling and locality are **performance-only**, erased by `q`.
* Resource exhaustion is an explicit **thermodynamic boundary**, not a bug.

---

## 1. Three Foundational Commitments (Re-stated Precisely)

### 1.1 Garbage Collection = Interning (Semantic Compression)

**Claim**
Garbage cleanup is obtained via canonical interning and deduplication, not via runtime tracing or sweeping.

**What this means**

* Duplicate structure is never created: equal-by-key nodes collapse to a single representative.
* Repeated computation yields reuse, not growth (Hashlife effect).
* The canonical store grows *monotonically*; there is no implicit reclamation.

**What this does *not* mean**

* Interning does not reclaim unique-but-dead structure.
* Space is not magically infinite.

**Corollary (Thermodynamic Framing)**
If computation produces irreducibly novel structure, it will eventually hit OOM or CORRUPT. This is an explicit semantic boundary, not a failure of engineering.

**Optional Extension (Still Lawful)**
A rebuild-from-roots (CQRS-style) is permitted as a *change of description* (renormalization), provided denotation is preserved:

```
pretty(denote(old_root)) == pretty(denote(new_root_after_rebuild))
```

---

### 1.2 Duplication / Sharing = Yoneda + Structural Identity

**Claim**
The system should never require a primitive “copy.” Apparent duplication arises from reuse of canonical structure.

**Operational Reading (Yoneda-style)**

* A value is determined by its interactions with contexts.
* “Using something twice” means *referencing the same representative in two contexts*.
* Interning ensures sharing is the default.

**Implication for CA micro-ops**

* No FAN primitive is required initially.
* Rewrites may create *bounded new structure*, but must not re-materialize existing subgraphs.

**Where λ-duplication shows up**

* As multiple edges pointing to the same canonical ID.
* Or as local demand/forcing tokens (if evaluation strategy requires it), not as structural copying.

**Testable Lemma**
A program with repeated use (e.g. `λx. f x x`) must not cause superlinear growth relative to the size of the forcing structure.

---

### 1.3 Binding Without Names

**Claim**
Binding is structural, not nominal. There are no names.

**Consequences**

* Alpha-equivalence collapses to literal structural equality after compilation.
* No global lookup tables.
* No capture by construction.

**Two viable representations (both lawful)**

1. **Pure wiring / interaction-net style**: variables are physically connected to binders.
2. **Coordinate-based (CD) addressing**: variables carry interned coordinate objects that resolve to binders via normalized structure.

The current architecture favors (2), but the semantics do not require committing prematurely.

**Testable Lemma**
Compiling `λx. x` and `λy. y` must yield the same canonical structure.

---

## 2. CNF-2, Fixed Arity, and Bounded Damage

### 2.1 CNF-2 as CA Rule Format

* Every rewrite site emits exactly **two candidate slots**.
* Slot enablement is explicit.
* This is the CA’s local update rule.

**Why this matters**

* Bounded fanout per interaction.
* Bounded propagation radius per superstep.
* Enables predictable locality and damage tracking.

---

### 2.2 “Damage” as the Only Reason to Go Global

The system distinguishes:

* **Local evolution**: interactions resolved entirely within a tile.
* **Damage**: interactions whose consequences cross tile boundaries or require higher-level identity resolution.

**Key Lemma**
Under CNF-2 and 2:1 tiling, the damage set per cycle is proportional to tile *perimeter*, not *volume*.

This is the Hashlife lineage made explicit.

**Note (m5 transition)**
`in-27` replaces the linear tile-boundary damage metric with a spectral Hamming
entropy model (MSB(A ⊕ B)) and an on-device servo mask. The m4 definition above
remains valid as a legacy locality signal; both are performance-only and erased
by `q`.

---

## 3. BSP, Sorting, and Locality (Polysemy Resolved)

### 3.1 BSPᵗ vs BSPˢ

* **BSPᵗ (Temporal)**: bulk-synchronous supersteps; stratum commits; `q` barriers.
* **BSPˢ (Spatial)**: binary space partitioning; tiling; Morton/2:1 packing.

**Commutation Contract**

```
denote(BSPᵗ ∘ BSPˢ (P)) == denote(BSPᵗ (P))
```

Spatial arrangement must not affect meaning.

---

### 3.2 Iterative Sorting as Renormalization

Sorting and swizzling are not semantic operations; they are **renormalization passes**:

* Improve locality.
* Shrink damage sets.
* Expose repetition.

They are erased by `q`.

---

## 4. Cayley–Dickson Coordinates and De Bruijn Intuition

### 4.1 Coordinates as Structural Scope Addresses

Binder nesting corresponds to **doubling of coordinate space**.

* Crossing a binder = algebraic transform on a coordinate object.
* “Shift” becomes coordinate composition.
* Normalization (XOR/parity) is algebraic, idempotent, and interned.

This is De Bruijn without integers; scope is a path in a recursively doubled space.

---

### 4.2 CDₐ vs CDᵣ (Algebra vs Representation)

* **CDₐ**: algebraic meaning (parity, cancellation).
* **CDᵣ**: structural DAG representation.

**Confluence Requirement**

```
canon(CDₐ ∘ CDᵣ(x)) == canon(CDᵣ ∘ CDₐ(x))
```

Normalization must occur *before* key packing.

---

## 5. Univalence, Interning, and Identity

### 5.1 Univalence Contract

* Identity is decided by **full key-byte equality**.
* Hashes, indices, and sorting are accelerators only.
* Fixed-width keys imply a **semantic ID cap**.

**Violations**

* Exceeding ID width → CORRUPT (semantic undefinedness).
* Exceeding capacity → OOM (resource exhaustion).

CORRUPT is forbidden; OOM is permitted.

---

### 5.2 `q` as the Semantic Boundary

* Evaluators may create provisional structure.
* The Ledger decides canonical identity.
* Denotation is defined only *after* projection through `q`.

**Homomorphic Collapse Law**

```
pretty(denote(q(eval_step(x)))) == pretty(denote(eval_step(q(x))))
```

---

## 6. Entropy, Compressibility, and Heat Death

### 6.1 Explicit Thermodynamic Boundary

* Canonical nodes = microstates.
* Ledger capacity = finite phase space.
* Programs that do not compress cannot run forever.

This is not an implementation accident; it is the explicit semantics.

---

### 6.2 Two Kinds of Death

* **OOM**: insufficient capacity; meaning still well-defined in principle.
* **CORRUPT**: identity ambiguity; meaning undefined.

Only CORRUPT is a hard semantic error.

---

### 6.3 Instrumentable Metrics

Useful observables:

* Δcanonical nodes per cycle
* reuse rate
* damage rate
* per-opcode entropy contribution

These classify computations as crystalline, glassy, or chaotic.

---

## 7. What “Very Simple CA” Means Here

Not:

* Binary-state, 2D, GoL-style rules.

But:

* Tiny finite alphabet.
* Constant-radius neighborhood.
* Fixed-arity (CNF-2) rewrite rules.
* Deterministic local physics.
* Canonical identity + quotient erasure.

This is a **graph-labeled CA / interaction-net CA**, optimized for your engine.

---

## 8. Lambda Calculus as CA-on-a-Lattice

### 8.1 Compilation Perspective

* λ AST → initial CA lattice configuration.
* Execution = CA evolution.
* Result = stable configuration interpreted via `pretty(denote(...))`.

### 8.2 Evaluation Bias

The architecture naturally favors:

* graph reduction
* call-by-need semantics

This is acceptable and should be made explicit in denotation.

---

## 9. Hierarchical Interning and “Global Is Small”

### 9.1 Tiled Interning Model

* Local tile interning first.
* Halo caches for neighbors.
* Damage sets escalated upward.
* Global merge only where damage demands it.

This replaces “global merge per batch” with **damage-scoped reconciliation**.

---

### 9.2 Compatibility with oneAPI / Accelerators

* Tile-local work maps to shared/local memory.
* Damage escalation maps to global queues.
* BSPᵗ barriers map to kernel boundaries.

The model is accelerator-native.

---

## 10. Meta-Rules (Non-Negotiables)

1. **Canonical identity is the only semantic identity.**
2. **Scheduling and locality must commute with denotation.**
3. **No-copy is an operational axiom.**
4. **Entropy limits are explicit and meaningful.**
5. **All polysemy must declare its axes and commutation laws.**

---

## 11. Closing Synthesis

What emerges is a system where:

* Computation is local physics.
* Meaning is a quotient.
* Sharing is default.
* Names never exist.
* Resource limits are honest.
* Complexity that does not compress is not punished — it simply cannot persist.

This is not “λ-calculus on a CA” as a stunt.
It is **λ-calculus as a compressible trajectory in a constrained physical phase space**, with Prism acting as the physics engine.

That framing is internally coherent, implementable, and — crucially — testable.