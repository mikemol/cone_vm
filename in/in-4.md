# The Hierarchical Fluid Memory: Mitigating Shatter via Morton-Ordered BSP Arenas

## 1. Introduction: Spatial Locality in Fluid Architectures

The previous analysis established the "Rank and Pack" paradigm, where memory is fluid and `OP_SORT` acts as the universal scheduler. However, a purely rank-based sort introduces a critical pathology known as the **Shatter Effect**. When the graph is sorted strictly by execution status (Active vs. Waiting), topologically adjacent nodes—such as a parent function and its child argument—may be pulled apart into distant memory regions if one is active and the other is not. This destroys cache locality, saturates memory bandwidth with random access (gather/scatter), and degrades the performance of the pointer swizzling pass.

To resolve this, we refine the architecture by constraining the global arena into a **Hierarchy of Arenas** modeled as a **2:1 Alternating Binary Space Partitioning (BSP) Tree**. By constraining the **Rank Scalar to 2 bits** and utilizing **Morton Order (Z-order curves)** as the secondary sort key, we enforce strict spatial locality. In this model, the `OP_SORT` operation does not merely prioritize tasks; it defragments the graph geometry, ensuring that logically connected subgraphs remain physically contiguous in memory.

---

## 2. The 2-Bit Rank Constraint

In this refined architecture, the scheduling logic is compressed into a minimal 2-bit state vector. This constraint forces the scheduler to be coarse-grained, delegating fine-grained ordering to the spatial layout (Section 3).

### 2.1 The Ontology of the 2-Bit Rank

The 2-bit scalar () defines the lifecycle of a node within the arena:

| Rank () | Binary | Semantics | Role in `OP_SORT` |
| --- | --- | --- | --- |
| **0** | `00` | **Active / Redex** | High Priority. The "Hot" frontier. Packed to the start of the arena for immediate execution. |
| **1** | `01` | **Dormant / Waiting** | The "Warm" data. Nodes connected to active nodes but not yet reducible. |
| **2** | `10` | **Inert / Storage** | The "Cold" data. Deeply nested graph structures or constants not currently reachable by the active wavefront. |
| **3** | `11` | **Garbage / Free** | Discarded memory. Packed to the end of the arena to be overwritten (implicit allocation). |

### 2.2 The Sort Key Composition

The global sort key  is no longer dominated by complex heuristics. It is a composition of the 2-bit Rank and the spatial Morton Index:

This simple lexicographical composition ensures that:

1. All **Active** nodes come first (Execution Wavefront).
2. All **Dormant** nodes come next.
3. **Crucially:** Within the *Active* set and within the *Dormant* set, nodes are ordered by their **Morton Index**. This preserves the geometric proximity of subgraphs even after they are separated by execution status.

---

## 3. The Arena as a 2:1 Alternating BSP Tree

To assign the `MortonIndex` and manage memory, we view the linear JAX array not as a flat tape, but as a flattened representation of a high-dimensional space managed by a Binary Space Partitioning (BSP) tree.

### 3.1 The 2:1 Alternating Topology

The Interaction Combinator graph is fundamentally binary (nodes have arity 2). We map this graph onto a memory structure that reflects this topology.

* **The Arena:** A fixed-size memory block  of size .
* **BSP Subdivision:** The arena is recursively divided. Level 0 is the whole arena. Level 1 splits it into two halves. Level 2 splits those into quarters.
* **2:1 Alternating:** The split axis alternates at each level (analogous to  and  axes in a 2D quadtree). This maps the binary graph structure to the linear memory such that a node at index  has children roughly at  and  in a heap-like layout, but linearized via a space-filling curve.

### 3.2 Morton Coding (Z-Order) for Graph Layout

We assign a logical "coordinate" to every node based on its path from the root of the computation.

* **Root:** coordinate .
* **Left Child:** moves in the  dimension.
* **Right Child:** moves in the  dimension.

The **Morton Code** is generated by interleaving the bits of these coordinates.


**Mitigating the Shatter Effect:**
When `OP_SORT` runs, it reorders nodes based on this Morton code. Because Morton order preserves locality (points close in 2D space are close on the Z-curve), subgraphs that are topologically connected (close in  space) will end up adjacent in the linear array.

* **Result:** When a parent node (Dormant) becomes Active, it is likely residing in a cache line adjacent to its siblings or children, significantly reducing the "gather" overhead during the Interaction phase.

---

## 4. The Hierarchy of Arenas

Scaling this to billions of nodes requires breaking the monolithic arena into a hierarchy. This constrains the "shatter" to local boundaries.

### 4.1 The Hierarchy Structure

* **L1 Arenas (Micro-Arenas):** Small, fixed-size blocks (e.g., 4KB, fitting in L1 cache/shared memory). These operate independently.
* **L2 Arenas (Macro-Arenas):** Aggregations of L1 arenas.
* **Global Arena:** The root container.

### 4.2 Hierarchical Sort and Pack

The `OP_SORT` pipeline becomes hierarchical:

1. **Local Sort (L1):** Each Micro-Arena sorts its internal nodes by Rank + Morton. This is an extremely fast register-level sort (e.g., bitonic sort) within a CUDA block or TPU core.
2. **Merge/Migration:** Nodes that effectively "move" (e.g., a Dormant node becoming Active) might need to migrate to a "hotter" arena. Instead of sorting the whole world, we perform a **Merge Sort** of the L1 arenas.
3. **Constrained Movement:** A node is only allowed to move within its level of the hierarchy. It cannot jump from index 0 to index  arbitrarily. It flows up or down the BSP tree.

This bounds the movement of data. The "Shatter Effect" is contained because a node can never be "shattered" further than the bounds of its current parent arena in the hierarchy.

---

## 5. Implementation in JAX: The IR Primitives

We expose this architecture via specific IR primitives in the self-hosted language.

### 5.1 `OP_MORTON` (Topological Indexing)

A JAX primitive that computes the Z-order index for the active frontier.

```python
@jit
def op_morton(manifest):
    # Extract topological depth/coordinates
    coords = manifest.coordinates 
    # Interleave bits to form sort key
    # x = coords[:, 0], y = coords[:, 1]
    # In JAX, bitwise operations are efficient
    morton_code = (x | (y << 1)) # simplified 1-bit interleave
    return morton_code

```

### 5.2 `OP_RANK_2BIT` (Status Classification)

A classifier that outputs the 2-bit status.

```python
@jit
def op_rank_2bit(manifest):
    # 00: Active (Principal ports connected)
    # 01: Waiting (Valid but not active)
    # 11: Free (Garbage)
    is_active = (manifest.target_port == manifest.self_index)
    is_free = (manifest.type == TYPE_FREE)
    
    return jnp.select(
        [is_free, is_active],
        , # 3=11(bin), 0=00(bin)
        default=1 # 1=01(bin) Waiting
    )

```

### 5.3 `OP_SORT` (The Scheduler)

The unified Rank-and-Pack kernel.

```python
@jit
def op_sort(manifest):
    rank = op_rank_2bit(manifest)
    morton = op_morton(manifest)
    
    # Composite Key: High bits = Rank, Low bits = Morton
    # This enforces: Active < Waiting < Garbage
    # AND: spatially close nodes stay close
    sort_key = (rank.astype(jnp.uint64) << 62) | morton.astype(jnp.uint64)
    
    # The Permutation
    perm = jnp.argsort(sort_key)
    
    # Swizzle and Pack in one pass
    return apply_permutation_and_swizzle(manifest, perm)

```

## 6. Summary of Architectural Advantages

| Feature | Problem Solved | Mechanism |
| --- | --- | --- |
| **2-Bit Rank** | Complexity overhead | Reduces scheduling to 4 states; simplifies sort key construction. |
| **Morton Order** | **Shatter Effect** | Preserves 2D/Graph topology within the 1D linear memory after sorting. |
| **BSP Arena** | Bandwidth saturation | Localizes memory access patterns; aligns data with hardware cache hierarchy. |
| **Hierarchical Sort** | Scalability | Replaces global  sort with local sorts + merge, enabling massive parallelism. |

This revised architecture transforms the interaction net evaluator into a **Spatially Aware Fluid Machine**, where data flows through memory not just by priority, but by geometry, ensuring optimal utilization of modern accelerator hardware.
