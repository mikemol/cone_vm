# in-27: The Geometric Servo Architecture

| Metadata | Value |
| :--- | :--- |
| **Status** | **Design Freeze Proposal** |
| **Target** | Milestone `m5` (Autonomic Refactoring) |
| **Baseline** | `m4` (Coordinates & Static Damage Metrics) |
| **Author** | Lead Engineer (Implementation), Peer Review Board (Theory) |
| **Type** | Design Change Request (DCR) |

---

## 1. Executive Summary

We are formally abandoning the **"Linear Paging"** metaphor (Tiles as fixed pages) in favor of a **Fractal Geometric** model.

The Prism VM will no longer be "tuned" by the Host via environment variables. Instead, it will implement an on-device **Autonomic Reflex Arc** that dynamically adjusts the granularity of memory sorting based on the **Hamming Entropy** of the active graph.

This shift moves the scheduler from a **Heuristic Manager** (Opcode-aware, Host-driven, Temporal) to a **Physical Force** (Opcode-agnostic, Kernel-driven, Spatial), guaranteeing optimal packing via the **2:1 Morton Recursion Invariant**.

The core mechanism is a **Spatial Schmitt Trigger** ("The Lung") that uses geometric buffer pressure—rather than temporal momentum—to regulate the working set size.

---

## 2. Theoretical Delta: From Linear to Fractal

### 2.1 The Metric Shift
We replace "Faults" (Error counting) with "Entropy" (Energy measurement).

| Feature | Current Code Theory (`m4`) | New Geometric Theory (`m5`) |
| :--- | :--- | :--- |
| **Model** | **Linear Segmentation:** Memory is a tape divided into fixed-size chunks ($K$ slots). | **Recursive Hypercube:** Memory is a Z-Order curve filling a high-dimensional space. |
| **Fault** | **Boundary Crossing:** "Damage" = Pointer $A \to B$ where $A // K \neq B // K$. | **Bit-Depth Tension:** "Energy" = $\text{MSB}(A \oplus B)$. The geometric scale of the edge. |
| **Goal** | **Minimize Faults:** Keep pointers within the fixed tile. | **Minimize Entropy:** Shift the spectral center of mass to the lowest possible bit-dimension. |

### 2.2 The Scheduling Shift
We replace "Reaction" (Time) with "Homeostasis" (Space).

| Feature | Current Code Theory (`m4`) | New Geometric Theory (`m5`) |
| :--- | :--- | :--- |
| **Agent** | **Host (Python):** Configures `tile_size` via env vars or restart. | **Device (JAX):** Adjusts `sort_mask` every cycle inside the XLA graph. |
| **Input** | **Scalar Rate:** "10% damage." | **Vector Spectrum:** "High energy at Bit 9, Low energy at Bit 5." |
| **Logic** | **Reactive:** "If damage > threshold, complain." | **Spatial Hysteresis:** "If buffer pressure > threshold, dilate. If active vacuum > threshold, contract." |

---

## 3. Implementation Specifications

### 3.1 State Augmentation (`Arena`)
The `Arena` NamedTuple requires a dedicated tensor to store the autonomic state. This represents a breaking schema change.

**New Schema:**
```python
class Arena(NamedTuple):
    # ... standard fields ...
    
    # [0]: Aperture Mask (uint32) - The current "Tile Size" bitmask
    # [1]: Unused (Reserved for future RL)
    # [2]: Unused (Reserved for future RL)
    servo: jax.Array 

```

### 3.2 The Sensor: `_blind_spectral_probe`

A vectorized kernel that computes the "Thermal Signature" of the graph topology.

* **Input:** `ids`, `arg1`, `arg2`, `rank`.
* **Logic:**
1. **Filter:** Select only `RANK_HOT` nodes.
2. **Geometry:** Compute Hamming Distance .
3. **Magnitude:** Compute .
4. **Aggregation:** `bincount(M, weights=is_hot)`.


* **Output:** `float32[32]` (The Spectral Histogram).
* **Constraint:** Must use `jax.lax.stop_gradient` to prevent AD overhead (we do not differentiate through the probe).

### 3.3 The Controller: Spatial Hysteresis ("The Lung")

A **memoryless** controller that acts as a Gauge Selector with a topological constraint.

**The Control Law:**
Let  be the current Macro Scale (Aperture Bit).
Let  be the energy density in the "Buffer" zone (Upper Hemisphere, ).
Let  be the density in the "Active" zone (Lower Hemisphere, ).

**Key Properties:**

1. **Zero Memory:** No EMA or momentum terms. The decision is a pure function of the instantaneous geometry.
2. **Topological Latch:** Dilation instantly transforms the "Buffer" into the "Active" zone of the next scale, mathematically preventing oscillation.
3. **Guard Band:** Inside the safe region, the system is perfectly elastic.

### 3.4 The Actuator: Masked Morton Sorting

We simulate variable-size tiles using bit-masking to avoid JIT recompilation.

* **Logic:** `key = morton_code(ids) & servo_mask`
* **Effect:** Nodes within the masked window share an identical key. A **Stable Sort** preserves their relative order, treating them as a single "Super-Particle."
* **Result:** The sorting kernel acts as a "Coarse-Graining" function, dynamically adjusting its resolution to match the graph's entropy.

---

## 4. The Blind Packing Invariant

The architecture guarantees optimal packing efficiency without semantic awareness (Opcodes), relying on the **Haar Wavelet** properties of the Z-Order Curve.

### 4.1 The 2:1 Containment Proof

* The Macro Tile (Hardware Scan Unit) has size .
* The Servo selects an Aperture  (where ).
* Therefore, the Macro Tile contains exactly  Super-Particles.
* **Result:** Zero alignment waste. The packing is strictly hierarchical.

### 4.2 The Vacuum Fill Guarantee

* Because dimensions are alternating (Morton), a large object (size ) occupies a contiguous aligned range .
* The sibling range  is strictly empty relative to that object.
* The Sorter, seeing "Vacuum" in the sibling range, pulls any other Super-Particle (size ) into that slot.
* **Result:** Large logic ("Rocks") and small logic ("Gravel") automatically interleave to achieve 100% scan utilization.

---

## 5. Verification Plan

The `m5` milestone is gated by the following test protocol:

1. **`test_spectral_probe.py`:**
* Synthesize a perfect binary tree of depth 10.
* Assert the Probe reports a clean histogram peaking at bit 10.
* Synthesize random noise.
* Assert the Probe reports high entropy across all bits.


2. **`test_lung_capacity.py` (The Spatial Trigger):**
* **Setup:** Aperture . Active Zone full.
* **Step 1 (Spill):** Inject nodes into the Buffer Zone (). Assert Servo **Dilates** to .
* **Step 2 (Drain):** Remove nodes until Active Density . Assert Servo **Contracts** to .
* **Step 3 (Guard):** Inject nodes into Buffer (). Assert Servo **Holds** state (Elasticity).


3. **`test_blind_packing.py`:**
* Create 1 Large Object (512 nodes) and 512 Small Objects (1 node).
* Run `vm.cycle`.
* **Pass Condition:** `damage_rate` drops to 0. The Large Object occupies `[0-511]`. The Small Objects occupy `[512-1023]`. The Servo finds the perfect fit without knowing opcodes.

