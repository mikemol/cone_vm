---
doc_revision: 1
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
---

NOTE: REFINED by in-14.md and IMPLEMENTATION_PLAN.md; this doc remains the consolidation rationale.

Here’s the reconciliation: **in-10 defines the milestone delta**, **in-11 makes the delta “self-hosting” by turning coordinates into IR objects**, and **in-12 supplies the *systems* pattern that guarantees univalence (canonicality without ambiguity) even under collisions**. Together they form one coherent architecture.

---

## 1) Single consolidated thesis

**Prism becomes an event-sourced canonical interner whose “read model” is a Ledger of CNF-2 nodes; Cayley–Dickson (CD) coordinates are not metadata but *interned CNF-2 objects*; aggregation is canonicalization over that coordinate space; and univalence is enforced by deterministic interning with full-key equality, not by hash uniqueness.**   

That sentence is literally “in-10 + in-11 + in-12” merged.

---

## 2) Roles of in-10, in-11, in-12

### in-10: *What changes, what doesn’t*

* Keeps Arena/Ledger/CNF-2 row shape `(opcode,arg1,arg2)` invariant.
* Changes the meaning of aggregation: from tree-local rewrites → **CD-addressed normalization** (“coordinate coincidence” locality). 

### in-11: *How CD-addressing becomes mechanically real*

* Introduces `OP_COORD_ZERO/ONE/PAIR`.
* Represents **each coordinate as an interned pointer into the same Ledger**; coordinate equality becomes pointer equality; XOR/parity becomes structural rewriting. 

### in-12: *How you get strong canonicality / univalence*

* Treat interning/rewrite as an **append-only event log** (commands) plus **materialized indexes** (queries).
* “Collision-free” is reinterpreted correctly: you can’t forbid hash collisions in finite bits, but you can guarantee **no ambiguity** by full-key comparison (or by using a trie). 

---

## 3) The reconciled design, as a CQRS/Event-Sourced “vtable for structure”

### Command stream (event log)

Minimum viable commands:

* `Intern(op, a1, a2)`  (after canonicalization)
* optionally `Rewrite(old -> new)` / `Union(a,b)` for equivalence compression
* optionally `Snapshot(read_model_state)` for rebuild speed 

### Read model (materialized views)

Maintain:

* `nodes[id] = (op,a1,a2)` (the Ledger itself)
* `index[key_bytes] -> id` (lookup structure)
* optional `find(id)` if you introduce rewrite/union semantics 

This is exactly your **vtable analogy**: a deterministic policy + a table, just generalized from “method dispatch” to “structural identity dispatch.” 

---

## 4) Canonicality without ambiguity: what “univalence” means here

Univalence = **every proposed node maps to exactly one canonical id**, deterministically.

Mechanism (the key point from in-12):

* Hash (if used) is **only a bucket hint**.
* Actual equality is decided by **full key bytes** (or by a collision-free trie). 

Critical constraint (ties back to your current implementation):

* Avoid *key aliasing* from truncation (e.g., 16-bit child-id packing). Hash collisions are fine; **truncation collisions are ambiguity**. 

---

## 5) Where CD coordinates fit (and why this completes the story)

From in-11, CD coordinates are **first-class Ledger nodes**:

* `coord_ptr` is just an `int32` id into the same canonical store
* equality is pointer equality
* XOR/parity is definable as rewrite recursion over `OP_COORD_*` 

From in-10, aggregation semantics move to CD-address space:

* cancellation happens at “same coordinate,” not “adjacent in tree”
* normalization becomes an idempotent projection defined over coordinate structure 

Putting those together:

* **Aggregation canonicalization** becomes: “lift operands to coordinates → normalize parity in coordinate space → intern the resulting canonical coordinate/object”
* And because coordinates themselves are interned, a huge amount of normalization collapses to pointer reuse.

---

## 6) One reconciled acceptance checklist

This merges the acceptance criteria from in-10 and in-11, plus the univalence constraint from in-12:

1. **Coordinates are interned CNF-2 objects** (`OP_COORD_*`) and live in the same Ledger. 
2. **Coordinate equality is pointer equality** (no bitstring compare path). 
3. **Aggregation normal form is coordinate-based** (tree shape differences collapse). 
4. **Cancellation does not require adjacency**; it is coordinate-local parity.
5. **Canonicalization is idempotent** (`canon(canon(x)) == canon(x)`). 
6. **Univalence holds even under collisions**: lookup uses full-key equality (or trie), never hash-only. 
7. **No ambiguity from packing**: child-id encoding must not truncate in a way that merges distinct keys. 

---

If you want the next “hard step,” it’s to choose the read-model index structure that best matches JAX constraints:

* **Trie/radix on packed bytes** (literal collision-free indexing)
* **Hash buckets + full-key compare** (collision-tolerant, still univalent) 

Either way, the reconciliation above is consistent: **event log → deterministic materialized index → canonical Ledger**, with **CD coordinates self-hosted as CNF-2 nodes** and **aggregation defined as coordinate-normalization**.